#!/usr/bin/env python3

import array
import click
import itertools
import skimage.io
import skimage.filters


@click.group()
def cli():
    pass


# --- Utility functions -------------------------------------------------------

def load_image(path):
     # Load the input as gray scale
    img = skimage.io.imread(path, as_gray = True)

    # Filter the input to enforce a 1 bit image
    threshold = skimage.filters.threshold_otsu(img)
    img = img > threshold

    # Job done
    return img


def build_framebuffer_data(img):
    ret = array.array('B', itertools.repeat(0, img.shape[0] * img.shape[1] // 8))
    for k, (i, j) in enumerate(itertools.product(range(img.shape[0] // 8), range(img.shape[1]))):
        for b in range(8):
            if img[i * 8 + b][j]:
                ret[k] |= 1 << b
    
    return ret


def decode_binary(bits):
    return sum(2 ** i for i, b in enumerate(bits) if b > 0)


def build_font_data(img, font_format):
    if font_format == '8x8':
        glyph_width, glyph_height = 8, 8
    elif font_format == '16x16':
        glyph_width, glyph_height = 16, 16

    glyph_data_size = (glyph_width * glyph_height) // 8
    
    ret = array.array('B', itertools.repeat(0, 256 * glyph_data_size))
    for k, (i, a, j, c) in enumerate(itertools.product(range(16), range(glyph_height // 8), range(16), range(glyph_width))):
        u, v = glyph_width * j + c, glyph_height * i
        ret[k] = decode_binary(img[v+8*a:v+8*(a+1),u])
        
    return ret


def generate_c_array(out, data, array_name):
    out.write('#include <stdint.h>\n')
    out.write('const __flash uint8_t\n')
    out.write(f'{array_name}[{len(data)}] = {{\n')
    out.write(', '.join(f'0x{byte:02x}' for byte in data))
    out.write('\n};\n')


# --- Framebuffer data generation ---------------------------------------------

@cli.command()
@click.option('--array-name', show_default  =True, default = 'framebuffer_data', help = "Name of the generated array.")
@click.argument('input_path', type = click.Path(exists = True, dir_okay = False))
def to_framebuffer(array_name, input_path):
    """
    Convert a bitmap picture to raw data for a SSD1306 oled screen set in 
    horizontal addressing mode
    """
    img = load_image(input_path)
    data = build_framebuffer_data(img)
    generate_c_array(click.get_text_stream('stdout'), data, array_name)


# --- Font data generation ----------------------------------------------------

@cli.command()
@click.option('--array-name', show_default = True, default = 'font_data', help = "Name of the generated array.")
@click.option('--font-format', type=click.Choice(['8x8', '16x16'], case_sensitive = False), default = '8x8')
@click.argument('input_path', type = click.Path(exists = True, dir_okay = False))
def to_font(array_name, font_format, input_path):
    """
    Convert a bitmap picture to 8x8 font data for a SSD1306 oled screen set in
    horizontal addressing mode
    """
    img = load_image(input_path)
    if img.shape[0] != 128 or img.shape[1] != 128:
        click.echo(message = "Invalid input picture dimension, should be 128x128", err = True)
        raise RuntimeError()
    
    data = build_font_data(img, font_format)
    generate_c_array(click.get_text_stream('stdout'), data, array_name)


# --- Main entry point --------------------------------------------------------

if __name__ == "__main__":
    cli()
