#!/usr/bin/env python3

import sys
import array
import click
import itertools
import skimage.io
import skimage.filters


@click.group()
def cli():
    pass


# --- Utility functions -------------------------------------------------------

def load_image(path):
     # Load the input as gray scale
    img = skimage.io.imread(path, as_gray = True)

    # Filter the input to enforce a 1 bit image
    threshold = skimage.filters.threshold_otsu(img)
    img = img > threshold

    # Job done
    return img


def build_framebuffer_data(img):
    ret = array.array('B', itertools.repeat(0, img.shape[0] * img.shape[1] // 8))
    for k, (i, j) in enumerate(itertools.product(range(img.shape[0] // 8), range(img.shape[1]))):
        for b in range(8):
            if img[i * 8 + b][j]:
                ret[k] |= 1 << b
    
    return ret


def generate_c_array(out, data, array_name):
    out.write('#include <stdint.h>\n')
    out.write('const __flash uint8_t\n')
    out.write(f'{array_name}[{len(data)}] = {{\n')
    out.write(', '.join(f'0x{byte:02x}' for byte in data))
    out.write('\n};\n')


# --- Framebuffer data generation ---------------------------------------------

@cli.command()
@click.option('--array-name', show_default  =True, default = 'framebuffer_data', help = "Name of the generated array.")
@click.argument('input_path', type = click.Path(exists = True, dir_okay = False))
def to_framebuffer(array_name, input_path):
    """
    Convert a bitmap picture to raw data for a SSD1306 oled screen in horizontal addressing mode
    """
    img = load_image(input_path)
    data = build_framebuffer_data(img)
    generate_c_array(sys.stdout, data, array_name)


# --- Main entry point --------------------------------------------------------

if __name__ == "__main__":
    cli()
