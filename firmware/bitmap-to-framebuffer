#!/usr/bin/env python3

import sys
import array
import argparse
import itertools
import skimage.io
import skimage.filters


def load_image(path):
     # Load the input as gray scale
    img = skimage.io.imread(path, as_gray = True)

    # Filter the input to enforce a 1 bit image
    threshold = skimage.filters.threshold_otsu(img)
    img = img > threshold

    # Job done
    return img


def build_framebuffer_data(img):
    ret = array.array('B', itertools.repeat(0, img.shape[0] * img.shape[1] // 8))
    for k, (i, j) in enumerate(itertools.product(range(img.shape[0] // 8), range(img.shape[1]))):
        for b in range(8):
            if img[i * 8 + b][j]:
                ret[k] |= 1 << b
    
    return ret


def generate_c_array(out, data, array_name):
    out.write('#include <stdint.h>\n')
    out.write('const __flash uint8_t\n')
    out.write(f'{array_name}[{len(data)}] = {{\n')
    out.write(', '.join(f'0x{byte:02x}' for byte in data))
    out.write('\n};\n')


def main():
    # Command line arguments
    parser = argparse.ArgumentParser(description = 'Convert a bitmap picture to raw data for a SSD1306 oled screen in horizontal addressing mode')
    parser.add_argument('--array-name', default = 'framebuffer_data')
    parser.add_argument('input_path')

    args = parser.parse_args()

    # Processing
    img = load_image(args.input_path)
    data = build_framebuffer_data(img)
    generate_c_array(sys.stdout, data, args.array_name)


if __name__ == "__main__":
    main()
